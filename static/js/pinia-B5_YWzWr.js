import{r as K,m as L,j as Q,i as X,w as Y,a as Z,f as A,k as R,t as tt,l as nt,q as et,s as st,n as ot,v as ct,c as at}from"./@vue-BS1r8QP-.js";let T;const I=t=>T=t,U=Symbol();function J(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var P,q;function pt(){const t=Q(!0),c=t.run(()=>K({}));let o=[],n=[];const a=L({install(r){I(a),a._a=r,r.provide(U,a),r.config.globalProperties.$pinia=a,n.forEach(y=>o.push(y)),n=[]},use(r){return this._a?o.push(r):n.push(r),this},_p:o,_a:null,_e:t,_s:new Map,state:c});return a}(q=P||(P={})).direct="direct",q.patchObject="patch object",q.patchFunction="patch function";const V=()=>{};function D(t,c,o,n=V){t.push(c);const a=()=>{const r=t.indexOf(c);r>-1&&(t.splice(r,1),n())};return!o&&et()&&st(a),a}function j(t,...c){t.slice().forEach(o=>{o(...c)})}const rt=t=>t(),G=Symbol(),C=Symbol();function N(t,c){t instanceof Map&&c instanceof Map?c.forEach((o,n)=>t.set(n,o)):t instanceof Set&&c instanceof Set&&c.forEach(t.add,t);for(const o in c){if(!c.hasOwnProperty(o))continue;const n=c[o],a=t[o];J(a)&&J(n)&&t.hasOwnProperty(o)&&!A(n)&&!R(n)?t[o]=N(a,n):t[o]=n}return t}const it=Symbol(),{assign:v}=Object;function H(t,c,o={},n,a,r){let y;const l=v({actions:{}},o),W={deep:!0};let _,f,m,h=[],O=[];const d=n.state.value[t];let $;function w(e){let s;_=f=!1,typeof e=="function"?(e(n.state.value[t]),s={type:P.patchFunction,storeId:t,events:m}):(N(n.state.value[t],e),s={type:P.patchObject,payload:e,storeId:t,events:m});const u=$=Symbol();ot().then(()=>{$===u&&(_=!0)}),f=!0,j(h,s,n.state.value[t])}r||d||(n.state.value[t]={}),K({});const M=r?function(){const{state:e}=o,s=e?e():{};this.$patch(u=>{v(u,s)})}:V,E=(e,s="")=>{if(G in e)return e[C]=s,e;const u=function(){I(n);const x=Array.from(arguments),g=[],F=[];let S;j(O,{args:x,name:u[C],store:i,after:function(p){g.push(p)},onError:function(p){F.push(p)}});try{S=e.apply(this&&this.$id===t?this:i,x)}catch(p){throw j(F,p),p}return S instanceof Promise?S.then(p=>(j(g,p),p)).catch(p=>(j(F,p),Promise.reject(p))):(j(g,S),S)};return u[G]=!0,u[C]=s,u},k={_p:n,$id:t,$onAction:D.bind(null,O),$patch:w,$reset:M,$subscribe(e,s={}){const u=D(h,e,s.detached,()=>x()),x=y.run(()=>Y(()=>n.state.value[t],g=>{(s.flush==="sync"?f:_)&&e({storeId:t,type:P.direct,events:m},g)},v({},W,s)));return u},$dispose:function(){y.stop(),h=[],O=[],n._s.delete(t)}},i=Z(k);n._s.set(t,i);const b=(n._a&&n._a.runWithContext||rt)(()=>n._e.run(()=>(y=Q()).run(()=>c({action:E}))));for(const e in b){const s=b[e];if(A(s)&&(!A(B=s)||!B.effect)||R(s))r||(!d||J(z=s)&&z.hasOwnProperty(it)||(A(s)?s.value=d[e]:N(s,d[e])),n.state.value[t][e]=s);else if(typeof s=="function"){const u=E(s,e);b[e]=u,l.actions[e]=s}}var z,B;return v(i,b),v(tt(i),b),Object.defineProperty(i,"$state",{get:()=>n.state.value[t],set:e=>{w(s=>{v(s,e)})}}),n._p.forEach(e=>{v(i,y.run(()=>e({store:i,app:n._a,pinia:n,options:l})))}),d&&r&&o.hydrate&&o.hydrate(i.$state,d),_=!0,f=!0,i}function lt(t,c,o){let n,a;const r=typeof c=="function";function y(l,W){const _=nt();return(l=l||(_?X(U,null):null))&&I(l),(l=T)._s.has(n)||(r?H(n,c,a,l):function(f,m,h){const{state:O,actions:d,getters:$}=m,w=h.state.value[f];let M;M=H(f,function(){w||(h.state.value[f]=O?O():{});const E=ct(h.state.value[f]);return v(E,d,Object.keys($||{}).reduce((k,i)=>(k[i]=L(at(()=>{I(h);const b=h._s.get(f);return $[i].call(b,b)})),k),{}))},m,h,0,!0)}(n,a,l)),l._s.get(n)}return typeof t=="string"?(n=t,a=r?o:c):(a=t,n=t.id),y.$id=n,y}export{pt as c,lt as d};
