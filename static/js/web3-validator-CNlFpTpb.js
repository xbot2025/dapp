import{X as V,Y as tt,y as U,D as rt,Z as st}from"./web3-errors-DMH_yRvG.js";import{B as it,T as et}from"./web3-types-DPR2whjI.js";import{k as nt}from"./ethereum-cryptography-CHyfgW_b.js";import{u as at}from"./@noble-ymNIOX9z.js";import{Z as S,z as d}from"./zod-BmijhD1c.js";const ot=t=>t.message?t.message:"unspecified error";class x extends V{constructor(r){super(),this.code=tt,this.errors=r,super.message=`Web3 validator found ${r.length} error[s]:
${this._compileErrors().join(`
`)}`}_compileErrors(){return this.errors.map(ot)}}const lt=["bool","int","uint","bytes","string","address","tuple"],M=t=>typeof t=="object"&&"type"in t&&"name"in t,f=t=>typeof t=="string"&&/^((-)?0x[0-9a-f]+|(0x))$/i.test(t),At=t=>typeof t=="number"||typeof t=="bigint"||typeof t=="string"&&/^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(t),ut=["hex","number","blockNumber","blockNumberOrTag","filter","bloom"],b=t=>{let r,s=t.replace(/ /,""),i=!1,e=[];if(t.includes("[")&&(s=s.slice(0,s.indexOf("[")),e=[...t.matchAll(/(?:\[(\d*)\])/g)].map(n=>parseInt(n[1],10)).map(n=>Number.isNaN(n)?-1:n),i=e.length>0),lt.includes(s))return{baseType:s,isArray:i,baseTypeSize:r,arraySizes:e};if(s.startsWith("int"))r=parseInt(s.substring(3),10),s="int";else if(s.startsWith("uint"))r=parseInt(t.substring(4),10),s="uint";else{if(!s.startsWith("bytes"))return{baseType:void 0,isArray:!1,baseTypeSize:void 0,arraySizes:e};r=parseInt(s.substring(5),10),s="bytes"}return{baseType:s,isArray:i,baseTypeSize:r,arraySizes:e}},q=(t,r={})=>{if(Object.keys(r).includes("type"))throw new x([{keyword:"eth",message:'Either "eth" or "type" can be presented in schema',params:{eth:t},instancePath:"",schemaPath:""}]);const{baseType:s,baseTypeSize:i}=b(t);if(!s&&!ut.includes(t))throw new x([{keyword:"eth",message:`Eth data type "${t}" is not valid`,params:{eth:t},instancePath:"",schemaPath:""}]);if(s){if(s==="tuple")throw new Error('"tuple" type is not implemented directly.');return{format:`${s}${i??""}`,required:!0}}return t?{format:t,required:!0}:{}},T=(t,r="/0")=>{const s={type:"array",items:[],maxItems:t.length,minItems:t.length};for(const[i,e]of t.entries()){let n,a,o=[];M(e)?(n=e.type,a=e.name||`${r}/${i}`,o=e.components):typeof e=="string"?(n=e,a=`${r}/${i}`):Array.isArray(e)&&(e[0]&&typeof e[0]=="string"&&e[0].startsWith("tuple")&&!Array.isArray(e[0])&&e[1]&&Array.isArray(e[1])?(n=e[0],a=`${r}/${i}`,o=e[1]):(n="tuple",a=`${r}/${i}`,o=e));const{baseType:c,isArray:p,arraySizes:m}=b(n);let y,u=s;for(let l=m.length-1;l>0;l-=1)y={type:"array",$id:a,items:[],maxItems:m[l],minItems:m[l]},m[l]<0&&(delete y.maxItems,delete y.minItems),Array.isArray(u.items)?u.items.length===0?u.items=[y]:u.items.push(y):u.items=[u.items,y],u=y;if(c!=="tuple"||p)if(c==="tuple"&&p){const l=m[0],v=Object.assign({type:"array",$id:a,items:T(o,a)},l>=0&&{minItems:l,maxItems:l});u.items.push(v)}else if(p){const l=m[0],v=Object.assign({type:"array",$id:a,items:q(n)},l>=0&&{minItems:l,maxItems:l});u.items.push(v)}else Array.isArray(u.items),u.items.push(Object.assign({$id:a},q(n)));else{const l=T(o,a);l.$id=a,u.items.push(l)}u=s}return s},G=t=>T(t),N=(t,r)=>r===1?t:N(t[0],r-1),I=(t,r,s)=>{const i=[];for(const[e,n]of t.entries()){let a,o,c=[];M(n)?(a=n.type,o=n.name,c=n.components):typeof n=="string"?a=n:Array.isArray(n)&&(n[1]&&Array.isArray(n[1])?(a=n[0],c=n[1]):(a="tuple",c=n));const{baseType:p,isArray:m,arraySizes:y}=b(a),u=Array.isArray(r)?r[e]:r[o];if(p!=="tuple"||m)if(p==="tuple"&&m){const l=[];for(const v of u)if(y.length>1){const K=N(v,y.length-1),P=[];for(const Q of K)P.push(I(c,Q,s));l.push(P)}else l.push(I(c,v,s));i.push(l)}else i.push(u);else i.push(I(c,u,s))}return(s=s??[]).push(...i),s},k=t=>{if(!f(t))throw new Error("Invalid hex string");const[r,s]=t.startsWith("-")?[!0,t.slice(1)]:[!1,t],i=BigInt(s);return i>Number.MAX_SAFE_INTEGER?r?-i:i:i<Number.MIN_SAFE_INTEGER?i:r?-1*Number(i):Number(i)},E=t=>{if((typeof t=="number"||typeof t=="bigint")&&t<0)return`-0x${t.toString(16).slice(1)}`;if((typeof t=="number"||typeof t=="bigint")&&t>=0)return`0x${t.toString(16)}`;if(typeof t=="string"&&f(t)){const[r,s]=t.startsWith("-")?[!0,t.slice(1)]:[!1,t];return`${r?"-":""}0x${s.split(/^(-)?0(x|X)/).slice(-1)[0].replace(/^0+/,"").toLowerCase()}`}if(typeof t=="string"&&!f(t))return E(BigInt(t));throw new rt(t)},mt=(t,r,s="0")=>{if(typeof t=="string"&&!f(t))return t.padStart(r,s);const i=typeof t=="string"&&f(t)?t:E(t),[e,n]=i.startsWith("-")?["-0x",i.slice(3)]:["0x",i.slice(2)];return`${e}${n.padStart(r,s)}`};function j(t){let r="0x";for(const s of t){const i=s.toString(16);r+=i.length===1?`0${i}`:i}return r}const C=48,ft=57,F=65,yt=70,X=97,ct=102;function J(t){return t>=C&&t<=ft?t-C:t>=F&&t<=yt?t-(F-10):t>=X&&t<=ct?t-(X-10):void 0}function H(t){let r=0;if(!t.startsWith("0")||t[1]!=="x"&&t[1]!=="X"||(r=2),t.length%2!=0)throw new U(`hex string has odd length: ${t}`);const s=(t.length-r)/2,i=new Uint8Array(s);for(let e=0,n=r;e<s;e+=1){const a=J(t.charCodeAt(n++)),o=J(t.charCodeAt(n++));if(a===void 0||o===void 0)throw new U(`Invalid byte sequence ("${t[n-2]}${t[n-1]}" in "${t}").`);i[e]=16*a+o}return i}function R(t){var r;return t instanceof Uint8Array||((r=t==null?void 0:t.constructor)===null||r===void 0?void 0:r.name)!=="Uint8Array"?t:Uint8Array.from(t)}const $t=Object.freeze(Object.defineProperty({__proto__:null,abiSchemaToJsonSchema:T,codePointToInt:t=>{if(t>=48&&t<=57)return t-48;if(t>=65&&t<=70)return t-55;if(t>=97&&t<=102)return t-87;throw new Error(`Invalid code point: ${t}`)},ensureIfUint8Array:R,ethAbiToJsonSchema:G,fetchArrayElement:N,hexToNumber:k,hexToUint8Array:H,numberToHex:E,padLeft:mt,parseBaseType:b,transformJsonDataToAbiFormat:I,uint8ArrayToHexString:j},Symbol.toStringTag,{value:"Module"})),z=t=>{var r,s;return t instanceof Uint8Array||((r=t==null?void 0:t.constructor)===null||r===void 0?void 0:r.name)==="Uint8Array"||((s=t==null?void 0:t.constructor)===null||s===void 0?void 0:s.name)==="Buffer"},D=(t,r={abiType:"bytes"})=>{if(typeof t!="string"&&!Array.isArray(t)&&!z(t)||typeof t=="string"&&f(t)&&t.startsWith("-")||typeof t=="string"&&!f(t))return!1;let s;if(typeof t=="string"){if(t.length%2!=0)return!1;s=H(t)}else if(Array.isArray(t)){if(t.some(i=>i<0||i>255||!Number.isInteger(i)))return!1;s=new Uint8Array(t)}else s=t;if(r!=null&&r.abiType){const{baseTypeSize:i}=b(r.abiType);return!i||s.length===i}return!(r!=null&&r.size)||s.length===(r==null?void 0:r.size)},w=(t,r=!0)=>{if(typeof t!="string"&&!z(t))return!1;let s;return s=z(t)?j(t):typeof t!="string"||f(t)||t.toLowerCase().startsWith("0x")?t:`0x${t}`,!!/^(0x)?[0-9a-f]{40}$/i.test(s)&&(!(!/^(0x|0X)?[0-9a-f]{40}$/.test(s)&&!/^(0x|0X)?[0-9A-F]{40}$/.test(s))||!r||(i=>{if(!/^(0x)?[0-9a-f]{40}$/i.test(i))return!1;const e=i.slice(2),n=at(e.toLowerCase()),a=j(nt(R(n))).slice(2);for(let o=0;o<40;o+=1)if(parseInt(a[o],16)>7&&e[o].toUpperCase()!==e[o]||parseInt(a[o],16)<=7&&e[o].toLowerCase()!==e[o])return!1;return!0})(s))},O=(t,r)=>{if(r===BigInt(0))return BigInt(1);let s=t;for(let i=1;i<r;i+=1)s*=t;return s},_=(t,r={abiType:"uint"})=>{if(!["number","string","bigint"].includes(typeof t)||typeof t=="string"&&t.length===0)return!1;let s;if(r!=null&&r.abiType){const{baseTypeSize:e}=b(r.abiType);e&&(s=e)}else r.bitSize&&(s=r.bitSize);const i=O(BigInt(2),BigInt(s??256))-BigInt(1);try{const e=typeof t=="string"&&f(t)?BigInt(k(t)):BigInt(t);return e>=0&&e<=i}catch{return!1}},W=(t,r={abiType:"int"})=>{if(!["number","string","bigint"].includes(typeof t)||typeof t=="number"&&t>Number.MAX_SAFE_INTEGER)return!1;let s;if(r!=null&&r.abiType){const{baseTypeSize:n,baseType:a}=b(r.abiType);if(a!=="int")return!1;n&&(s=n)}else r.bitSize&&(s=r.bitSize);const i=O(BigInt(2),BigInt((s??256)-1)),e=BigInt(-1)*O(BigInt(2),BigInt((s??256)-1));try{const n=typeof t=="string"&&f(t)?BigInt(k(t)):BigInt(t);return n>=e&&n<=i}catch{return!1}},pt=t=>!!W(t)||!(typeof t!="string"||!/[0-9.]/.test(t)||t.indexOf(".")!==t.lastIndexOf("."))||typeof t=="number",Z=t=>_(t),Y=t=>Object.values(it).includes(t),B=t=>Y(t)||Z(t),h=t=>t==null,It=t=>!(typeof t!="object"||h(t)||Array.isArray(t)||t instanceof et),L=t=>typeof t=="string"&&!!/^(0x)?[0-9a-f]{64}$/i.test(t)&&!(!/^(0x)?[0-9a-f]{64}$/.test(t)&&!/^(0x)?[0-9A-F]{64}$/.test(t)),g={address:t=>w(t),bloom:t=>{return!(typeof(r=t)!="string"||!/^(0x)?[0-9a-f]{512}$/i.test(r)||!/^(0x)?[0-9a-f]{512}$/.test(r)&&!/^(0x)?[0-9A-F]{512}$/.test(r));var r},blockNumber:t=>Z(t),blockTag:t=>Y(t),blockNumberOrTag:t=>B(t),bool:t=>{return!!["number","string","boolean"].includes(typeof(r=t))&&(typeof r=="boolean"||(typeof r!="string"||f(r)?typeof r=="string"&&f(r)?r==="0x1"||r==="0x0":r===1||r===0:r==="1"||r==="0"));var r},bytes:t=>D(t),filter:t=>(r=>{const s=["fromBlock","toBlock","address","topics","blockHash"];if(h(r)||typeof r!="object"||!Object.keys(r).every(i=>s.includes(i))||!h(r.fromBlock)&&!B(r.fromBlock)||!h(r.toBlock)&&!B(r.toBlock))return!1;if(!h(r.address)){if(Array.isArray(r.address)){if(!r.address.every(i=>w(i)))return!1}else if(!w(r.address))return!1}return!(!h(r.topics)&&!r.topics.every(i=>!!h(i)||(Array.isArray(i)?i.every(e=>L(e)):!!L(i))))})(t),hex:t=>f(t),uint:t=>_(t),int:t=>W(t),number:t=>pt(t),string:t=>typeof t=="string"};for(let t=8;t<=256;t+=8)g[`int${t}`]=r=>W(r,{bitSize:t}),g[`uint${t}`]=r=>_(r,{bitSize:t});for(let t=1;t<=32;t+=1)g[`bytes${t}`]=r=>D(r,{size:t});g.bytes256=g.bytes;const $=t=>{if((!(t!=null&&t.type)||(t==null?void 0:t.type)==="object")&&(t!=null&&t.properties)){const r={};for(const s of Object.keys(t.properties)){const i=$(t.properties[s]);i&&(r[s]=i)}return Array.isArray(t.required)?d.object(r).partial().required(t.required.reduce((s,i)=>Object.assign(Object.assign({},s),{[i]:!0}),{})):d.object(r).partial()}if((t==null?void 0:t.type)==="array"&&(t!=null&&t.items)){if(Array.isArray(t.items)&&t.items.length>1&&t.maxItems!==void 0&&new Set(t.items.map(i=>i.$id)).size===t.items.length){const i=[];for(const e of t.items){const n=$(e);n&&i.push(n)}return d.tuple(i)}const r=Array.isArray(t.items)?t.items[0]:t.items;let s=d.array($(r));return s=t.minItems!==void 0?s.min(t.minItems):s,s=t.maxItems!==void 0?s.max(t.maxItems):s,s}if(t.oneOf&&Array.isArray(t.oneOf))return d.union(t.oneOf.map(r=>$(r)));if(t!=null&&t.format){if(!g[t.format])throw new st(t.format);return d.any().refine(g[t.format],r=>({params:{value:r,format:t.format}}))}return t!=null&&t.type&&(t==null?void 0:t.type)!=="object"&&typeof d[String(t.type)]=="function"?d[String(t.type)]():d.object({data:d.any()}).partial()};class A{static factory(){return A.validatorInstance||(A.validatorInstance=new A),A.validatorInstance}validate(r,s,i){var e,n;const a=$(r).safeParse(s);if(!a.success){const o=this.convertErrors((n=(e=a.error)===null||e===void 0?void 0:e.issues)!==null&&n!==void 0?n:[]);if(o){if(i!=null&&i.silent)return o;throw new x(o)}}}convertErrors(r){if(r&&Array.isArray(r)&&r.length>0)return r.map(s=>{var i;let e,n,a,o;o=s.path.join("/");const c=String(s.path[s.path.length-1]),p=s.path.join("/");if(s.code===S.too_big)n="maxItems",o=`${p}/maxItems`,a={limit:s.maximum},e=`must NOT have more than ${s.maximum} items`;else if(s.code===S.too_small)n="minItems",o=`${p}/minItems`,a={limit:s.minimum},e=`must NOT have fewer than ${s.minimum} items`;else if(s.code===S.custom){const{value:m,format:y}=(i=s.params)!==null&&i!==void 0?i:{};e=m===void 0?`value at "/${o}" is required`:`value "${typeof m=="object"?JSON.stringify(m):m}" at "/${o}" must pass "${y}" validation`,a={value:m}}return{keyword:n??c,instancePath:p?`/${p}`:"",schemaPath:o?`#${o}`:"#",params:a??{value:s.message},message:e??s.message}})}}const xt=new class{constructor(){this._validator=A.factory()}validateJSONSchema(t,r,s){return this._validator.validate(t,r,s)}validate(t,r,s={silent:!1}){var i,e;const n=G(t);if(!Array.isArray(n.items)||((i=n.items)===null||i===void 0?void 0:i.length)!==0||r.length!==0){if(Array.isArray(n.items)&&((e=n.items)===null||e===void 0?void 0:e.length)===0&&r.length!==0)throw new x([{instancePath:"/0",schemaPath:"/",keyword:"required",message:"empty schema against data can not be validated",params:r}]);return this._validator.validate(n,r,s)}}};export{x as W,w as a,f as b,pt as c,Y as d,D as e,R as f,k as g,H as h,h as i,$t as j,At as k,W as l,_ as m,E as n,It as o,mt as p,G as q,I as t,j as u,xt as v};
