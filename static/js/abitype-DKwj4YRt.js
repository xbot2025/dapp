function I(t,e){const s=t.exec(e);return s==null?void 0:s.groups}var k=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,B=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,P=/^\(.+?\).*?$/,Z=Object.defineProperty,b=(t,e,s)=>(((a,n,i)=>{n in a?Z(a,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[n]=i})(t,typeof e!="symbol"?e+"":e,s),s),u=class extends Error{constructor(t,e={}){var n;const s=e.cause instanceof u?e.cause.details:(n=e.cause)!=null&&n.message?e.cause.message:e.details,a=e.cause instanceof u&&e.cause.docsPath||e.docsPath;super([t||"An error occurred.","",...e.metaMessages?[...e.metaMessages,""]:[],...a?[`Docs: https://abitype.dev${a}`]:[],...s?[`Details: ${s}`]:[],"Version: abitype@0.7.1"].join(`
`)),b(this,"details"),b(this,"docsPath"),b(this,"metaMessages"),b(this,"shortMessage"),b(this,"name","AbiTypeError"),e.cause&&(this.cause=e.cause),this.details=s,this.docsPath=a,this.metaMessages=e.metaMessages,this.shortMessage=t}},S=/^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;function x(t){return S.test(t)}function D(t){return I(S,t)}var A=new Set(["memory","indexed","storage","calldata"]),O=new Set(["calldata","memory","storage"]),v=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]),j=/^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,N=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,T=/^u?int$/;function w(t,e){var l,f;const s=function(r,c){return c?`${c}:${r}`:r}(t,e==null?void 0:e.type);if(v.has(s))return v.get(s);const a=P.test(t),n=I(a?N:j,t);if(!n)throw new u("Invalid ABI parameter.",{details:t});if(n.name&&function(r){return r==="address"||r==="bool"||r==="function"||r==="string"||r==="tuple"||k.test(r)||B.test(r)||E.test(r)}(n.name))throw new u("Invalid ABI parameter.",{details:t,metaMessages:[`"${n.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]});const i=n.name?{name:n.name}:{},p=n.modifier==="indexed"?{indexed:!0}:{},o=(e==null?void 0:e.structs)??{};let d,y={};if(a){d="tuple";const r=g(n.type),c=[],$=r.length;for(let h=0;h<$;h++)c.push(w(r[h],{structs:o}));y={components:c}}else if(n.type in o)d="tuple",y={components:o[n.type]};else if(T.test(n.type))d=`${n.type}256`;else if(d=n.type,(e==null?void 0:e.type)!=="struct"&&!_(d))throw new u("Unknown type.",{metaMessages:[`Type "${d}" is not a valid ABI type.`]});if(n.modifier){if(!((f=(l=e==null?void 0:e.modifiers)==null?void 0:l.has)!=null&&f.call(l,n.modifier)))throw new u("Invalid ABI parameter.",{details:t,metaMessages:[`Modifier "${n.modifier}" not allowed${e!=null&&e.type?` in "${e.type}" type`:""}.`]});if(O.has(n.modifier)&&!function(r,c){return c||r==="bytes"||r==="string"||r==="tuple"}(d,!!n.array))throw new u("Invalid ABI parameter.",{details:t,metaMessages:[`Modifier "${n.modifier}" not allowed${e!=null&&e.type?` in "${e.type}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${n.modifier}" was given.`]})}const m={type:`${d}${n.array??""}`,...i,...p,...y};return v.set(s,m),m}function g(t,e=[],s="",a=0){if(t===""){if(s==="")return e;if(a!==0)throw new u("Unbalanced parentheses.",{metaMessages:[`"${s.trim()}" has too many ${a>0?"opening":"closing"} parentheses.`],details:`Depth "${a}"`});return[...e,s.trim()]}const n=t.length;for(let i=0;i<n;i++){const p=t[i],o=t.slice(i+1);switch(p){case",":return a===0?g(o,[...e,s.trim()]):g(o,e,`${s}${p}`,a);case"(":return g(o,e,`${s}${p}`,a+1);case")":return g(o,e,`${s}${p}`,a-1);default:return g(o,e,`${s}${p}`,a)}}return[]}function _(t){return t==="address"||t==="bool"||t==="function"||t==="string"||k.test(t)||B.test(t)}var E=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/,J=/^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;function z(t,e,s=new Set){const a=[],n=t.length;for(let i=0;i<n;i++){const p=t[i];if(P.test(p.type))a.push(p);else{const o=I(J,p.type);if(!(o!=null&&o.type))throw new u("Invalid ABI parameter.",{details:JSON.stringify(p,null,2),metaMessages:["ABI parameter type is invalid."]});const{array:d,type:y}=o;if(y in e){if(s.has(y))throw new u("Circular reference detected.",{metaMessages:[`Struct "${y}" is a circular reference.`]});a.push({...p,type:`tuple${d??""}`,components:z(e[y]??[],e,new Set([...s,y]))})}else{if(!_(y))throw new u("Unknown type.",{metaMessages:[`Type "${y}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]});a.push(p)}}}return a}function R(t){let e;if(typeof t=="string")e=w(t,{modifiers:A});else{const s=function(n){const i={},p=n.length;for(let m=0;m<p;m++){const l=n[m];if(!x(l))continue;const f=D(l);if(!f)throw new u("Invalid struct signature.",{details:l});const r=f.properties.split(";"),c=[],$=r.length;for(let h=0;h<$;h++){const M=r[h].trim();if(!M)continue;const U=w(M,{type:"struct"});c.push(U)}if(!c.length)throw new u("Invalid struct signature.",{details:l,metaMessages:["No properties exist."]});i[f.name]=c}const o={},d=Object.entries(i),y=d.length;for(let m=0;m<y;m++){const[l,f]=d[m];o[l]=z(f,i)}return o}(t),a=t.length;for(let n=0;n<a;n++){const i=t[n];if(!x(i)){e=w(i,{modifiers:A,structs:s});break}}}if(!e)throw new u("Failed to parse ABI parameter.",{details:`parseAbiParameter(${JSON.stringify(t,null,2)})`,docsPath:"/api/human.html#parseabiparameter-1"});return e}export{R as p};
