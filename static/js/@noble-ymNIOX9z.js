function at(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function ot(n,...t){if(!((e=n)instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"))throw new Error("Uint8Array expected");var e;if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function te(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");at(n.outputLen),at(n.blockLen)}function J(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function St(n,t){ot(n);const e=t.outputLen;if(n.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Me={number:at,bool:function(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)},bytes:ot,hash:te,exists:J,output:St},gt=BigInt(2**32-1),Tt=BigInt(32);function ce(n,t=!1){return t?{h:Number(n&gt),l:Number(n>>Tt&gt)}:{h:0|Number(n>>Tt&gt),l:0|Number(n&gt)}}function le(n,t=!1){let e=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let o=0;o<n.length;o++){const{h:s,l:u}=ce(n[o],t);[e[o],r[o]]=[s,u]}return[e,r]}const bt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,mt=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),V=(n,t)=>n<<32-t|n>>>t,Ft=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function $t(n){for(let e=0;e<n.length;e++)n[e]=(t=n[e])<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;var t}function de(n){if(typeof n!="string")throw new Error("utf8ToBytes expected string, got "+typeof n);return new Uint8Array(new TextEncoder().encode(n))}function wt(n){return typeof n=="string"&&(n=de(n)),ot(n),n}class Ot{clone(){return this._cloneInto()}}function ee(n){const t=r=>n().update(wt(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function ge(n=32){if(bt&&typeof bt.getRandomValues=="function")return bt.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}const ne=[],re=[],ie=[],pe=BigInt(0),ut=BigInt(1),we=BigInt(2),ye=BigInt(7),be=BigInt(256),me=BigInt(113);for(let n=0,t=ut,e=1,r=0;n<24;n++){[e,r]=[r,(2*e+3*r)%5],ne.push(2*(5*r+e)),re.push((n+1)*(n+2)/2%64);let o=pe;for(let s=0;s<7;s++)t=(t<<ut^(t>>ye)*me)%be,t&we&&(o^=ut<<(ut<<BigInt(s))-ut);ie.push(o)}const[Ee,Be]=le(ie,!0),Ct=(n,t,e)=>e>32?((r,o,s)=>o<<s-32|r>>>64-s)(n,t,e):((r,o,s)=>r<<s|o>>>32-s)(n,t,e),Pt=(n,t,e)=>e>32?((r,o,s)=>r<<s-32|o>>>64-s)(n,t,e):((r,o,s)=>o<<s|r>>>32-s)(n,t,e);class Lt extends Ot{constructor(t,e,r,o=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=o,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,at(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var u;this.state=new Uint8Array(200),this.state32=(u=this.state,new Uint32Array(u.buffer,u.byteOffset,Math.floor(u.byteLength/4)))}keccak(){Ft||$t(this.state32),function(t,e=24){const r=new Uint32Array(10);for(let o=24-e;o<24;o++){for(let f=0;f<10;f++)r[f]=t[f]^t[f+10]^t[f+20]^t[f+30]^t[f+40];for(let f=0;f<10;f+=2){const i=(f+8)%10,l=(f+2)%10,b=r[l],c=r[l+1],x=Ct(b,c,1)^r[i],R=Pt(b,c,1)^r[i+1];for(let g=0;g<50;g+=10)t[f+g]^=x,t[f+g+1]^=R}let s=t[2],u=t[3];for(let f=0;f<24;f++){const i=re[f],l=Ct(s,u,i),b=Pt(s,u,i),c=ne[f];s=t[c],u=t[c+1],t[c]=l,t[c+1]=b}for(let f=0;f<50;f+=10){for(let i=0;i<10;i++)r[i]=t[f+i];for(let i=0;i<10;i++)t[f+i]^=~r[(i+2)%10]&r[(i+4)%10]}t[0]^=Ee[o],t[1]^=Be[o]}r.fill(0)}(this.state32,this.rounds),Ft||$t(this.state32),this.posOut=0,this.pos=0}update(t){J(this);const{blockLen:e,state:r}=this,o=(t=wt(t)).length;for(let s=0;s<o;){const u=Math.min(e-this.pos,o-s);for(let f=0;f<u;f++)r[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:o}=this;t[r]^=e,128&e&&r===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){J(this,!1),ot(t),this.finish();const e=this.state,{blockLen:r}=this;for(let o=0,s=t.length;o<s;){this.posOut>=r&&this.keccak();const u=Math.min(r-this.posOut,s-o);t.set(e.subarray(this.posOut,this.posOut+u),o),this.posOut+=u,o+=u}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return at(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(St(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:o,rounds:s,enableXOF:u}=this;return t||(t=new Lt(e,r,o,u,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=o,t.enableXOF=u,t.destroyed=this.destroyed,t}}const Ge=((n,t,e)=>ee(()=>new Lt(t,n,e)))(1,136,32);class oe extends Ot{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,te(t);const r=wt(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let u=0;u<s.length;u++)s[u]^=54;this.iHash.update(s),this.oHash=t.create();for(let u=0;u<s.length;u++)s[u]^=106;this.oHash.update(s),s.fill(0)}update(t){return J(this),this.iHash.update(t),this}digestInto(t){J(this),ot(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:u,outputLen:f}=this;return t.finished=o,t.destroyed=s,t.blockLen=u,t.outputLen=f,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const se=(n,t,e)=>new oe(n,t).update(e).digest();se.create=(n,t)=>new oe(n,t);const xe=(n,t,e)=>n&t^n&e^t&e;class Ie extends Ot{constructor(t,e,r,o){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=mt(this.buffer)}update(t){J(this);const{view:e,buffer:r,blockLen:o}=this,s=(t=wt(t)).length;for(let u=0;u<s;){const f=Math.min(o-this.pos,s-u);if(f!==o)r.set(t.subarray(u,u+f),this.pos),this.pos+=f,u+=f,this.pos===o&&(this.process(e,0),this.pos=0);else{const i=mt(t);for(;o<=s-u;u+=o)this.process(i,u)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){J(this),St(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:u}=this;e[u++]=128,this.buffer.subarray(u).fill(0),this.padOffset>o-u&&(this.process(r,0),u=0);for(let c=u;c<o;c++)e[c]=0;(function(c,x,R,g){if(typeof c.setBigUint64=="function")return c.setBigUint64(x,R,g);const a=BigInt(32),d=BigInt(4294967295),B=Number(R>>a&d),y=Number(R&d),E=g?4:0,L=g?0:4;c.setUint32(x+E,B,g),c.setUint32(x+L,y,g)})(r,o-8,BigInt(8*this.length),s),this.process(r,0);const f=mt(t),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=i/4,b=this.get();if(l>b.length)throw new Error("_sha2: outputLen bigger than state");for(let c=0;c<l;c++)f.setUint32(4*c,b[c],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:u,pos:f}=this;return t.length=o,t.pos=f,t.finished=s,t.destroyed=u,o%e&&t.buffer.set(r),t}}const ve=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),K=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),M=new Uint32Array(64);class Ae extends Ie{constructor(){super(64,32,8,!1),this.A=0|K[0],this.B=0|K[1],this.C=0|K[2],this.D=0|K[3],this.E=0|K[4],this.F=0|K[5],this.G=0|K[6],this.H=0|K[7]}get(){const{A:t,B:e,C:r,D:o,E:s,F:u,G:f,H:i}=this;return[t,e,r,o,s,u,f,i]}set(t,e,r,o,s,u,f,i){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|o,this.E=0|s,this.F=0|u,this.G=0|f,this.H=0|i}process(t,e){for(let x=0;x<16;x++,e+=4)M[x]=t.getUint32(e,!1);for(let x=16;x<64;x++){const R=M[x-15],g=M[x-2],a=V(R,7)^V(R,18)^R>>>3,d=V(g,17)^V(g,19)^g>>>10;M[x]=d+M[x-7]+a+M[x-16]|0}let{A:r,B:o,C:s,D:u,E:f,F:i,G:l,H:b}=this;for(let x=0;x<64;x++){const R=b+(V(f,6)^V(f,11)^V(f,25))+((c=f)&i^~c&l)+ve[x]+M[x]|0,g=(V(r,2)^V(r,13)^V(r,22))+xe(r,o,s)|0;b=l,l=i,i=f,f=u+R|0,u=s,s=o,o=r,r=R+g|0}var c;r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,u=u+this.D|0,f=f+this.E|0,i=i+this.F|0,l=l+this.G|0,b=b+this.H|0,this.set(r,o,s,u,f,i,l,b)}roundClean(){M.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Se=ee(()=>new Ae),zt=BigInt(0),pt=BigInt(1),Oe=BigInt(2);function Q(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function lt(n){if(!Q(n))throw new Error("Uint8Array expected")}const Le=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function rt(n){lt(n);let t="";for(let e=0;e<n.length;e++)t+=Le[n[e]];return t}function Zt(n){const t=n.toString(16);return 1&t.length?`0${t}`:t}function Rt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const Vt=48,Re=57,jt=65,Ue=70,Dt=97,ke=102;function Kt(n){return n>=Vt&&n<=Re?n-Vt:n>=jt&&n<=Ue?n-(jt-10):n>=Dt&&n<=ke?n-(Dt-10):void 0}function it(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){const u=Kt(n.charCodeAt(s)),f=Kt(n.charCodeAt(s+1));if(u===void 0||f===void 0){const i=n[s]+n[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}r[o]=16*u+f}return r}function W(n){return Rt(rt(n))}function Ut(n){return lt(n),Rt(rt(Uint8Array.from(n).reverse()))}function nt(n,t){return it(n.toString(16).padStart(2*t,"0"))}function kt(n,t){return nt(n,t).reverse()}function Z(n,t,e){let r;if(typeof t=="string")try{r=it(t)}catch(s){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${s}`)}else{if(!Q(t))throw new Error(`${n} must be hex string or Uint8Array`);r=Uint8Array.from(t)}const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${n} expected ${e} bytes, got ${o}`);return r}function ht(...n){let t=0;for(let r=0;r<n.length;r++){const o=n[r];lt(o),t+=o.length}const e=new Uint8Array(t);for(let r=0,o=0;r<n.length;r++){const s=n[r];e.set(s,o),o+=s.length}return e}const qt=n=>(Oe<<BigInt(n-1))-pt,Et=n=>new Uint8Array(n),Mt=n=>Uint8Array.from(n);function fe(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Et(n),o=Et(n),s=0;const u=()=>{r.fill(1),o.fill(0),s=0},f=(...b)=>e(o,r,...b),i=(b=Et())=>{o=f(Mt([0]),b),r=f(),b.length!==0&&(o=f(Mt([1]),b),r=f())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let b=0;const c=[];for(;b<t;){r=f();const x=r.slice();c.push(x),b+=r.length}return ht(...c)};return(b,c)=>{let x;for(u(),i(b);!(x=c(l()));)i();return u(),x}}const qe={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||Q(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function ct(n,t,e={}){const r=(o,s,u)=>{const f=qe[s];if(typeof f!="function")throw new Error(`Invalid validator "${s}", expected function`);const i=n[o];if(!(u&&i===void 0||f(i,n)))throw new Error(`Invalid param ${String(o)}=${i} (${typeof i}), expected ${s}`)};for(const[o,s]of Object.entries(t))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return n}const Ne=Object.freeze(Object.defineProperty({__proto__:null,abytes:lt,bitGet:function(n,t){return n>>BigInt(t)&pt},bitLen:function(n){let t;for(t=0;n>zt;n>>=pt,t+=1);return t},bitMask:qt,bitSet:function(n,t,e){return n|(e?pt:zt)<<BigInt(t)},bytesToHex:rt,bytesToNumberBE:W,bytesToNumberLE:Ut,concatBytes:ht,createHmacDrbg:fe,ensureBytes:Z,equalBytes:function(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0},hexToBytes:it,hexToNumber:Rt,isBytes:Q,numberToBytesBE:nt,numberToBytesLE:kt,numberToHexUnpadded:Zt,numberToVarBytesBE:function(n){return it(Zt(n))},utf8ToBytes:function(n){if(typeof n!="string")throw new Error("utf8ToBytes expected string, got "+typeof n);return new Uint8Array(new TextEncoder().encode(n))},validateObject:ct},Symbol.toStringTag,{value:"Module"})),H=BigInt(0),N=BigInt(1),Y=BigInt(2),He=BigInt(3),Bt=BigInt(4),Gt=BigInt(5),Yt=BigInt(8);function T(n,t){const e=n%t;return e>=H?e:t+e}function Te(n,t,e){if(e<=H||t<H)throw new Error("Expected power/modulo > 0");if(e===N)return H;let r=N;for(;t>H;)t&N&&(r=r*n%e),n=n*n%e,t>>=N;return r}function C(n,t,e){let r=n;for(;t-- >H;)r*=r,r%=e;return r}function It(n,t){if(n===H||t<=H)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=T(n,t),r=t,o=H,s=N;for(;e!==H;){const u=r%e,f=o-s*(r/e);r=e,e=u,o=s,s=f}if(r!==N)throw new Error("invert: does not exist");return T(o,t)}function Fe(n){if(n%Bt===He){const t=(n+N)/Bt;return function(e,r){const o=e.pow(r,t);if(!e.eql(e.sqr(o),r))throw new Error("Cannot find square root");return o}}if(n%Yt===Gt){const t=(n-Gt)/Yt;return function(e,r){const o=e.mul(r,Y),s=e.pow(o,t),u=e.mul(r,s),f=e.mul(e.mul(u,Y),s),i=e.mul(u,e.sub(f,e.ONE));if(!e.eql(e.sqr(i),r))throw new Error("Cannot find square root");return i}}return function(t){const e=(t-N)/Y;let r,o,s;for(r=t-N,o=0;r%Y===H;r/=Y,o++);for(s=Y;s<t&&Te(s,e,t)!==t-N;s++);if(o===1){const f=(t+N)/Bt;return function(i,l){const b=i.pow(l,f);if(!i.eql(i.sqr(b),l))throw new Error("Cannot find square root");return b}}const u=(r+N)/Y;return function(f,i){if(f.pow(i,e)===f.neg(f.ONE))throw new Error("Cannot find square root");let l=o,b=f.pow(f.mul(f.ONE,s),r),c=f.pow(i,u),x=f.pow(i,r);for(;!f.eql(x,f.ONE);){if(f.eql(x,f.ZERO))return f.ZERO;let R=1;for(let a=f.sqr(x);R<l&&!f.eql(a,f.ONE);R++)a=f.sqr(a);const g=f.pow(b,N<<BigInt(l-R-1));b=f.sqr(g),c=f.mul(c,g),x=f.mul(x,b),l=R}return c}}(n)}BigInt(9),BigInt(16);const $e=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ue(n,t){const e=t!==void 0?t:n.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function ae(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function Wt(n){const t=ae(n);return t+Math.ceil(t/2)}const Ce=BigInt(0),xt=BigInt(1);function he(n){return ct(n.Fp,$e.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),ct(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ue(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}const{bytesToNumberBE:Pe,hexToBytes:ze}=Ne,X={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(n){const{Err:t}=X;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const e=n[1],r=n.subarray(2,e+2);if(!e||r.length!==e)throw new t("Invalid signature integer: wrong length");if(128&r[0])throw new t("Invalid signature integer: negative");if(r[0]===0&&!(128&r[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Pe(r),l:n.subarray(e+2)}},toSig(n){const{Err:t}=X,e=typeof n=="string"?ze(n):n;lt(e);let r=e.length;if(r<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:o,l:s}=X._parseInt(e.subarray(2)),{d:u,l:f}=X._parseInt(s);if(f.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:u}},hexFromSig(n){const t=l=>8&Number.parseInt(l[0],16)?"00"+l:l,e=l=>{const b=l.toString(16);return 1&b.length?`0${b}`:b},r=t(e(n.s)),o=t(e(n.r)),s=r.length/2,u=o.length/2,f=e(s),i=e(u);return`30${e(u+s+4)}02${i}${o}02${f}${r}`}},j=BigInt(0),P=BigInt(1);BigInt(2);const Xt=BigInt(3);function Ze(n){const t=function(g){const a=he(g);ct(a,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:d,Fp:B,a:y}=a;if(d){if(!B.eql(y,B.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof d!="object"||typeof d.beta!="bigint"||typeof d.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...a})}(n),{Fp:e}=t,r=t.toBytes||((g,a,d)=>{const B=a.toAffine();return ht(Uint8Array.from([4]),e.toBytes(B.x),e.toBytes(B.y))}),o=t.fromBytes||(g=>{const a=g.subarray(1);return{x:e.fromBytes(a.subarray(0,e.BYTES)),y:e.fromBytes(a.subarray(e.BYTES,2*e.BYTES))}});function s(g){const{a,b:d}=t,B=e.sqr(g),y=e.mul(B,g);return e.add(e.add(y,e.mul(g,a)),d)}if(!e.eql(e.sqr(t.Gy),s(t.Gx)))throw new Error("bad generator point: equation left != right");function u(g){return typeof g=="bigint"&&j<g&&g<t.n}function f(g){if(!u(g))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function i(g){const{allowedPrivateKeyLengths:a,nByteLength:d,wrapPrivateKey:B,n:y}=t;if(a&&typeof g!="bigint"){if(Q(g)&&(g=rt(g)),typeof g!="string"||!a.includes(g.length))throw new Error("Invalid key");g=g.padStart(2*d,"0")}let E;try{E=typeof g=="bigint"?g:W(Z("private key",g,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof g}`)}return B&&(E=T(E,y)),f(E),E}const l=new Map;function b(g){if(!(g instanceof c))throw new Error("ProjectivePoint expected")}class c{constructor(a,d,B){if(this.px=a,this.py=d,this.pz=B,a==null||!e.isValid(a))throw new Error("x required");if(d==null||!e.isValid(d))throw new Error("y required");if(B==null||!e.isValid(B))throw new Error("z required")}static fromAffine(a){const{x:d,y:B}=a||{};if(!a||!e.isValid(d)||!e.isValid(B))throw new Error("invalid affine point");if(a instanceof c)throw new Error("projective point not allowed");const y=E=>e.eql(E,e.ZERO);return y(d)&&y(B)?c.ZERO:new c(d,B,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const d=e.invertBatch(a.map(B=>B.pz));return a.map((B,y)=>B.toAffine(d[y])).map(c.fromAffine)}static fromHex(a){const d=c.fromAffine(o(Z("pointHex",a)));return d.assertValidity(),d}static fromPrivateKey(a){return c.BASE.multiply(i(a))}_setWindowSize(a){this._WINDOW_SIZE=a,l.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:a,y:d}=this.toAffine();if(!e.isValid(a)||!e.isValid(d))throw new Error("bad point: x or y not FE");const B=e.sqr(d),y=s(a);if(!e.eql(B,y))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){b(a);const{px:d,py:B,pz:y}=this,{px:E,py:L,pz:A}=a,m=e.eql(e.mul(d,A),e.mul(E,y)),I=e.eql(e.mul(B,A),e.mul(L,y));return m&&I}negate(){return new c(this.px,e.neg(this.py),this.pz)}double(){const{a,b:d}=t,B=e.mul(d,Xt),{px:y,py:E,pz:L}=this;let A=e.ZERO,m=e.ZERO,I=e.ZERO,v=e.mul(y,y),w=e.mul(E,E),h=e.mul(L,L),p=e.mul(y,E);return p=e.add(p,p),I=e.mul(y,L),I=e.add(I,I),A=e.mul(a,I),m=e.mul(B,h),m=e.add(A,m),A=e.sub(w,m),m=e.add(w,m),m=e.mul(A,m),A=e.mul(p,A),I=e.mul(B,I),h=e.mul(a,h),p=e.sub(v,h),p=e.mul(a,p),p=e.add(p,I),I=e.add(v,v),v=e.add(I,v),v=e.add(v,h),v=e.mul(v,p),m=e.add(m,v),h=e.mul(E,L),h=e.add(h,h),v=e.mul(h,p),A=e.sub(A,v),I=e.mul(h,w),I=e.add(I,I),I=e.add(I,I),new c(A,m,I)}add(a){b(a);const{px:d,py:B,pz:y}=this,{px:E,py:L,pz:A}=a;let m=e.ZERO,I=e.ZERO,v=e.ZERO;const w=t.a,h=e.mul(t.b,Xt);let p=e.mul(d,E),S=e.mul(B,L),O=e.mul(y,A),U=e.add(d,B),q=e.add(E,L);U=e.mul(U,q),q=e.add(p,S),U=e.sub(U,q),q=e.add(d,y);let k=e.add(E,A);return q=e.mul(q,k),k=e.add(p,O),q=e.sub(q,k),k=e.add(B,y),m=e.add(L,A),k=e.mul(k,m),m=e.add(S,O),k=e.sub(k,m),v=e.mul(w,q),m=e.mul(h,O),v=e.add(m,v),m=e.sub(S,v),v=e.add(S,v),I=e.mul(m,v),S=e.add(p,p),S=e.add(S,p),O=e.mul(w,O),q=e.mul(h,q),S=e.add(S,O),O=e.sub(p,O),O=e.mul(w,O),q=e.add(q,O),p=e.mul(S,q),I=e.add(I,p),p=e.mul(k,q),m=e.mul(U,m),m=e.sub(m,p),p=e.mul(U,S),v=e.mul(k,v),v=e.add(v,p),new c(m,I,v)}subtract(a){return this.add(a.negate())}is0(){return this.equals(c.ZERO)}wNAF(a){return R.wNAFCached(this,l,a,d=>{const B=e.invertBatch(d.map(y=>y.pz));return d.map((y,E)=>y.toAffine(B[E])).map(c.fromAffine)})}multiplyUnsafe(a){const d=c.ZERO;if(a===j)return d;if(f(a),a===P)return this;const{endo:B}=t;if(!B)return R.unsafeLadder(this,a);let{k1neg:y,k1:E,k2neg:L,k2:A}=B.splitScalar(a),m=d,I=d,v=this;for(;E>j||A>j;)E&P&&(m=m.add(v)),A&P&&(I=I.add(v)),v=v.double(),E>>=P,A>>=P;return y&&(m=m.negate()),L&&(I=I.negate()),I=new c(e.mul(I.px,B.beta),I.py,I.pz),m.add(I)}multiply(a){f(a);let d,B,y=a;const{endo:E}=t;if(E){const{k1neg:L,k1:A,k2neg:m,k2:I}=E.splitScalar(y);let{p:v,f:w}=this.wNAF(A),{p:h,f:p}=this.wNAF(I);v=R.constTimeNegate(L,v),h=R.constTimeNegate(m,h),h=new c(e.mul(h.px,E.beta),h.py,h.pz),d=v.add(h),B=w.add(p)}else{const{p:L,f:A}=this.wNAF(y);d=L,B=A}return c.normalizeZ([d,B])[0]}multiplyAndAddUnsafe(a,d,B){const y=c.BASE,E=(A,m)=>m!==j&&m!==P&&A.equals(y)?A.multiply(m):A.multiplyUnsafe(m),L=E(this,d).add(E(a,B));return L.is0()?void 0:L}toAffine(a){const{px:d,py:B,pz:y}=this,E=this.is0();a==null&&(a=E?e.ONE:e.inv(y));const L=e.mul(d,a),A=e.mul(B,a),m=e.mul(y,a);if(E)return{x:e.ZERO,y:e.ZERO};if(!e.eql(m,e.ONE))throw new Error("invZ was invalid");return{x:L,y:A}}isTorsionFree(){const{h:a,isTorsionFree:d}=t;if(a===P)return!0;if(d)return d(c,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:d}=t;return a===P?this:d?d(c,this):this.multiplyUnsafe(t.h)}toRawBytes(a=!0){return this.assertValidity(),r(c,this,a)}toHex(a=!0){return rt(this.toRawBytes(a))}}c.BASE=new c(t.Gx,t.Gy,e.ONE),c.ZERO=new c(e.ZERO,e.ONE,e.ZERO);const x=t.nBitLength,R=function(g,a){const d=(y,E)=>{const L=E.negate();return y?L:E},B=y=>({windows:Math.ceil(a/y)+1,windowSize:2**(y-1)});return{constTimeNegate:d,unsafeLadder(y,E){let L=g.ZERO,A=y;for(;E>Ce;)E&xt&&(L=L.add(A)),A=A.double(),E>>=xt;return L},precomputeWindow(y,E){const{windows:L,windowSize:A}=B(E),m=[];let I=y,v=I;for(let w=0;w<L;w++){v=I,m.push(v);for(let h=1;h<A;h++)v=v.add(I),m.push(v);I=v.double()}return m},wNAF(y,E,L){const{windows:A,windowSize:m}=B(y);let I=g.ZERO,v=g.BASE;const w=BigInt(2**y-1),h=2**y,p=BigInt(y);for(let S=0;S<A;S++){const O=S*m;let U=Number(L&w);L>>=p,U>m&&(U-=h,L+=xt);const q=O,k=O+Math.abs(U)-1,F=S%2!=0,$=U<0;U===0?v=v.add(d(F,E[q])):I=I.add(d($,E[k]))}return{p:I,f:v}},wNAFCached(y,E,L,A){const m=y._WINDOW_SIZE||1;let I=E.get(y);return I||(I=this.precomputeWindow(y,m),m!==1&&E.set(y,A(I))),this.wNAF(m,I,L)}}}(c,t.endo?Math.ceil(x/2):x);return{CURVE:t,ProjectivePoint:c,normPrivateKeyToScalar:i,weierstrassEquation:s,isWithinCurveOrder:u}}function Ve(n){const t=function(w){const h=he(w);return ct(h,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...h})}(n),{Fp:e,n:r}=t,o=e.BYTES+1,s=2*e.BYTES+1;function u(w){return T(w,r)}function f(w){return It(w,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:l,weierstrassEquation:b,isWithinCurveOrder:c}=Ze({...t,toBytes(w,h,p){const S=h.toAffine(),O=e.toBytes(S.x),U=ht;return p?U(Uint8Array.from([h.hasEvenY()?2:3]),O):U(Uint8Array.from([4]),O,e.toBytes(S.y))},fromBytes(w){const h=w.length,p=w[0],S=w.subarray(1);if(h!==o||p!==2&&p!==3){if(h===s&&p===4)return{x:e.fromBytes(S.subarray(0,e.BYTES)),y:e.fromBytes(S.subarray(e.BYTES,2*e.BYTES))};throw new Error(`Point of length ${h} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}{const U=W(S);if(!(j<(O=U)&&O<e.ORDER))throw new Error("Point is not on curve");const q=b(U);let k;try{k=e.sqrt(q)}catch(F){const $=F instanceof Error?": "+F.message:"";throw new Error("Point is not on curve"+$)}return!(1&~p)!=((k&P)===P)&&(k=e.neg(k)),{x:U,y:k}}var O}}),x=w=>rt(nt(w,t.nByteLength));function R(w){return w>r>>P}const g=(w,h,p)=>W(w.slice(h,p));class a{constructor(h,p,S){this.r=h,this.s=p,this.recovery=S,this.assertValidity()}static fromCompact(h){const p=t.nByteLength;return h=Z("compactSignature",h,2*p),new a(g(h,0,p),g(h,p,2*p))}static fromDER(h){const{r:p,s:S}=X.toSig(Z("DER",h));return new a(p,S)}assertValidity(){if(!c(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!c(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(h){return new a(this.r,this.s,h)}recoverPublicKey(h){const{r:p,s:S,recovery:O}=this,U=E(Z("msgHash",h));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const q=O===2||O===3?p+t.n:p;if(q>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const k=1&O?"03":"02",F=i.fromHex(k+x(q)),$=f(q),_=u(-U*$),st=u(S*$),D=i.BASE.multiplyAndAddUnsafe(F,_,st);if(!D)throw new Error("point at infinify");return D.assertValidity(),D}hasHighS(){return R(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,u(-this.s),this.recovery):this}toDERRawBytes(){return it(this.toDERHex())}toDERHex(){return X.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return it(this.toCompactHex())}toCompactHex(){return x(this.r)+x(this.s)}}const d={isValidPrivateKey(w){try{return l(w),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const w=Wt(t.n);return function(h,p,S=!1){const O=h.length,U=ae(p),q=Wt(p);if(O<16||O<q||O>1024)throw new Error(`expected ${q}-1024 bytes of input, got ${O}`);const k=T(S?W(h):Ut(h),p-N)+N;return S?kt(k,U):nt(k,U)}(t.randomBytes(w),t.n)},precompute:(w=8,h=i.BASE)=>(h._setWindowSize(w),h.multiply(BigInt(3)),h)};function B(w){const h=Q(w),p=typeof w=="string",S=(h||p)&&w.length;return h?S===o||S===s:p?S===2*o||S===2*s:w instanceof i}const y=t.bits2int||function(w){const h=W(w),p=8*w.length-t.nBitLength;return p>0?h>>BigInt(p):h},E=t.bits2int_modN||function(w){return u(y(w))},L=qt(t.nBitLength);function A(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(j<=w&&w<L))throw new Error(`bigint expected < 2^${t.nBitLength}`);return nt(w,t.nByteLength)}function m(w,h,p=I){if(["recovered","canonical"].some(G=>G in p))throw new Error("sign() legacy options not supported");const{hash:S,randomBytes:O}=t;let{lowS:U,prehash:q,extraEntropy:k}=p;U==null&&(U=!0),w=Z("msgHash",w),q&&(w=Z("prehashed msgHash",S(w)));const F=E(w),$=l(h),_=[A($),A(F)];if(k!=null&&k!==!1){const G=k===!0?O(e.BYTES):k;_.push(Z("extraEntropy",G))}const st=ht(..._),D=F;return{seed:st,k2sig:function(G){const ft=y(G);if(!c(ft))return;const dt=f(ft),tt=i.BASE.multiply(ft).toAffine(),z=u(tt.x);if(z===j)return;const et=u(dt*u(D+z*$));if(et===j)return;let Nt=(tt.x===z?0:2)|Number(tt.y&P),Ht=et;return U&&R(et)&&(Ht=function(yt){return R(yt)?u(-yt):yt}(et),Nt^=1),new a(z,Ht,Nt)}}}const I={lowS:t.lowS,prehash:!1},v={lowS:t.lowS,prehash:!1};return i.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(w,h=!0){return i.fromPrivateKey(w).toRawBytes(h)},getSharedSecret:function(w,h,p=!0){if(B(w))throw new Error("first arg must be private key");if(!B(h))throw new Error("second arg must be public key");return i.fromHex(h).multiply(l(w)).toRawBytes(p)},sign:function(w,h,p=I){const{seed:S,k2sig:O}=m(w,h,p),U=t;return fe(U.hash.outputLen,U.nByteLength,U.hmac)(S,O)},verify:function(w,h,p,S=v){var tt;const O=w;if(h=Z("msgHash",h),p=Z("publicKey",p),"strict"in S)throw new Error("options.strict was renamed to lowS");const{lowS:U,prehash:q}=S;let k,F;try{if(typeof O=="string"||Q(O))try{k=a.fromDER(O)}catch(z){if(!(z instanceof X.Err))throw z;k=a.fromCompact(O)}else{if(typeof O!="object"||typeof O.r!="bigint"||typeof O.s!="bigint")throw new Error("PARSE");{const{r:z,s:et}=O;k=new a(z,et)}}F=i.fromHex(p)}catch(z){if(z.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(U&&k.hasHighS())return!1;q&&(h=t.hash(h));const{r:$,s:_}=k,st=E(h),D=f(_),G=u(st*D),ft=u($*D),dt=(tt=i.BASE.multiplyAndAddUnsafe(F,G,ft))==null?void 0:tt.toAffine();return!!dt&&u(dt.x)===$},ProjectivePoint:i,Signature:a,utils:d}}function je(n){return{hash:n,hmac:(t,...e)=>se(n,t,function(...r){let o=0;for(let u=0;u<r.length;u++){const f=r[u];ot(f),o+=f.length}const s=new Uint8Array(o);for(let u=0,f=0;u<r.length;u++){const i=r[u];s.set(i,f),f+=i.length}return s}(...e)),randomBytes:ge}}BigInt(4);const Jt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Qt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),De=BigInt(1),vt=BigInt(2),_t=(n,t)=>(n+t/vt)/t,At=function(n,t,e=!1,r={}){if(n<=H)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:o,nByteLength:s}=ue(n,t);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const u=Fe(n),f=Object.freeze({ORDER:n,BITS:o,BYTES:s,MASK:qt(o),ZERO:H,ONE:N,create:i=>T(i,n),isValid:i=>{if(typeof i!="bigint")throw new Error("Invalid field element: expected bigint, got "+typeof i);return H<=i&&i<n},is0:i=>i===H,isOdd:i=>(i&N)===N,neg:i=>T(-i,n),eql:(i,l)=>i===l,sqr:i=>T(i*i,n),add:(i,l)=>T(i+l,n),sub:(i,l)=>T(i-l,n),mul:(i,l)=>T(i*l,n),pow:(i,l)=>function(b,c,x){if(x<H)throw new Error("Expected power > 0");if(x===H)return b.ONE;if(x===N)return c;let R=b.ONE,g=c;for(;x>H;)x&N&&(R=b.mul(R,g)),g=b.sqr(g),x>>=N;return R}(f,i,l),div:(i,l)=>T(i*It(l,n),n),sqrN:i=>i*i,addN:(i,l)=>i+l,subN:(i,l)=>i-l,mulN:(i,l)=>i*l,inv:i=>It(i,n),sqrt:r.sqrt||(i=>u(f,i)),invertBatch:i=>function(l,b){const c=new Array(b.length),x=b.reduce((g,a,d)=>l.is0(a)?g:(c[d]=g,l.mul(g,a)),l.ONE),R=l.inv(x);return b.reduceRight((g,a,d)=>l.is0(a)?g:(c[d]=l.mul(g,c[d]),l.mul(g,a)),R),c}(f,i),cmov:(i,l,b)=>b?l:i,toBytes:i=>e?kt(i,s):nt(i,s),fromBytes:i=>{if(i.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${i.length}`);return e?Ut(i):W(i)}});return Object.freeze(f)}(Jt,void 0,void 0,{sqrt:function(n){const t=Jt,e=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),u=BigInt(23),f=BigInt(44),i=BigInt(88),l=n*n*n%t,b=l*l*n%t,c=C(b,e,t)*b%t,x=C(c,e,t)*b%t,R=C(x,vt,t)*l%t,g=C(R,o,t)*R%t,a=C(g,s,t)*g%t,d=C(a,f,t)*a%t,B=C(d,i,t)*d%t,y=C(B,f,t)*a%t,E=C(y,e,t)*b%t,L=C(E,u,t)*g%t,A=C(L,r,t)*l%t,m=C(A,vt,t);if(!At.eql(At.sqr(m),n))throw new Error("Cannot find square root");return m}}),Ke=function(n,t){const e=r=>Ve({...n,...je(r)});return Object.freeze({...e(t),create:e})}({a:BigInt(0),b:BigInt(7),Fp:At,n:Qt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=Qt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-De*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,u=BigInt("0x100000000000000000000000000000000"),f=_t(s*n,t),i=_t(-r*n,t);let l=T(n-f*e-i*o,t),b=T(-f*r-i*s,t);const c=l>u,x=b>u;if(c&&(l=t-l),x&&(b=t-b),l>u||b>u)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:c,k1:l,k2neg:x,k2:b}}}},Se);BigInt(0),Ke.ProjectivePoint;export{Me as a,Ge as k,ge as r,Ke as s,de as u};
